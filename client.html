<!doctype html>
<html>

<head>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <!-- This adapter.js file de-prefixes the webkit* and moz* prefixed RTC
             methods. When RTC becomes a more solid standard, this adapter should no
             longer be necessary. -->
  <!--        <script src="https://webrtc.googlecode.com/svn/trunk/samples/js/base/adapter.js"></script>-->
  <style>
    html,
    body {
      background-color: #333;
    }

    video {
      width: 320px;
      height: 240px;
      border: 1px solid black;
    }
  </style>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    var ICE_SERVERS = [{
      url: "stun:stun.l.google.com:19302"
    }];
  </script>


  <script>
    var signaling_socket = null; /* our socket.io connection to our webserver */
    var peers = {}; /* keep track of our peer connections, indexed by peer_id (aka socket.io id) */
    var peer_media_elements = {}; /* keep track of our <video>/<audio> tags, indexed by peer_id */

    function init() {
      console.log("Connecting to signaling server");
      signaling_socket = io.connect();

      signaling_socket.on('connect', function() {
        console.log("Connected to signaling server");
      });

      signaling_socket.on('disconnect', function() {

      });

      /**
       * When we join a group, our signaling server will send out 'addPeer' events to each pair
       * of users in the group (creating a fully-connected graph of users, ie if there are 6 people
       * in the channel you will connect directly to the other 5, so there will be a total of 15
       * connections in the network).
       */
      signaling_socket.on('addPeer', function(config) {
        var peer_id = config.peer_id;
        console.log('Signaling server said to add peer:', peer_id);
        if (peer_id in peers) {
          console.log("Already connected to peer ", peer_id);
          return;
        }

        var peer_connection = new webkitRTCPeerConnection({
          "iceServers": ICE_SERVERS
        }, {
          "optional": [{
            "DtlsSrtpKeyAgreement": true
          }]
        });

        peer_connection.dataChannel = peer_connection.createDataChannel("rtcbus");

        peers[peer_id] = peer_connection;

        peer_connection.onicecandidate = function(event) {
          if (event.candidate) {
            signaling_socket.emit('relayICECandidate', {
              'peer_id': peer_id,
              'ice_candidate': {
                'sdpMLineIndex': event.candidate.sdpMLineIndex,
                'candidate': event.candidate.candidate
              }
            });
          }
        }

        peer_connection.ondatachannel = function(event) {
          var receiveChannel = event.channel;
          receiveChannel.onmessage = function(event) {
            console.log('DC MESSAGE:', event);
          };
          receiveChannel.onopen = function(event) {
            console.log('DC OPEN:', event);
          };
          receiveChannel.onclose = function(event) {
            console.log('DC CLOSE:', event);
          };
        };

        // create offer if server says to.
        if (config.should_create_offer) {
          console.log("Creating RTC offer to ", peer_id);
          peer_connection.createOffer(
            function(local_description) {
              peer_connection.setLocalDescription(local_description,
                function() {
                  signaling_socket.emit('relaySessionDescription', {
                    'peer_id': peer_id,
                    'session_description': local_description
                  });
                },
                function() {
                  console.warn("Offer setLocalDescription failed!");
                }
              );
            },
            function(error) {
              console.log("Error sending offer: ", error);
            });
        } else {
          console.log('no creating offer');
        }
      });

      signaling_socket.on('sessionDescription', function(config) {
        console.log('Remote description received: ', config);
        var peer_id = config.peer_id;
        var peer = peers[peer_id];
        var remote_description = config.session_description;

        var desc = new RTCSessionDescription(remote_description);
        var stuff = peer.setRemoteDescription(desc,
          function() {
            if (remote_description.type == "offer") {
              peer.createAnswer(
                function(local_description) {
                  peer.setLocalDescription(local_description,
                    function() {
                      signaling_socket.emit('relaySessionDescription', {
                        'peer_id': peer_id,
                        'session_description': local_description
                      });
                    },
                    function() {
                      Alert("Answer setLocalDescription failed!");
                    }
                  );
                },
                function(error) {
                  console.warn("Error creating answer: ", error);
                });
            }
          },
          function(error) {
            console.log("setRemoteDescription error: ", error);
          }
        );
        console.log("Description Object: ", desc);

      });

      signaling_socket.on('iceCandidate', function(config) {
        var peer = peers[config.peer_id];
        var ice_candidate = config.ice_candidate;
        peer.addIceCandidate(new RTCIceCandidate(ice_candidate));
      });

      signaling_socket.on('removePeer', function(peer_id) {
        console.log('Signaling server said to remove peer:', peer_id);
        var peer_id = peer_id;

        if (peer_id in peers) {
          peers[peer_id].close();
        }
        delete peers[peer_id];
      });
    }
  </script>
</head>

<body onload='init()'>
</body>

</html>
